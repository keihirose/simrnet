simrnet <- function(object, num.obs = c(50, 100, 200, 300, 500, 1000), num.test = 1000, times.sim = 100, nfolds.glmnet=10, msg = TRUE){
    if(class(object)!="genpar") stop("The class of \"object\" must be genpar, which is generated by genpar function.")
    if(class(num.obs)!="numeric") stop("\"num.obs\" must be a numeric vector.")
    if(sum(num.obs>0)!=length(num.obs>0)) stop("All of the elements of \"num.obs\" must be positive integers.")
    if(class(num.test)!="numeric") stop("\"num.test\" must be numeric.")
    if(num.test<=0) stop("\"num.test\" must be a positive integer.")
    if(class(times.sim)!="numeric") stop("\"times.sim\" must be numeric.")
    if(times.sim<=0) stop("\"times.sim\" must be a positive integer.")
    if(class(nfolds.glmnet)!="numeric") stop("\"nfolds.glmnet\" must be numeric.")
    if(nfolds.glmnet<=0) stop("\"nfolds.glmnet\" must be a positive integer.")
    if(class(msg)!="logical") stop("\"msg\" must be logical.")

    #Extract variables from "object"
    A.all <- object$A
    res <- object$res
    sd.error <- object$sd.error
    p <- object$p
    mu <- object$mu


    # simulation
    RMSE <- R_square <- vector(3, mode = "list")
    names(RMSE) <- names(R_square) <- paste("Sigma", 1:3, sep="")
    
    for(num.Sigma in 1:3){
      
        if(msg) cat(paste("Monte Carlo simulation for Sigma", num.Sigma, ": computing", sep = ""))
        RMSE[[num.Sigma]] <- R_square[[num.Sigma]] <- vector(2, mode = "list")  # image of structure : 1-1, 1-2, 2-1, 2-2, 3-1, 3-2
        names(RMSE[[num.Sigma]]) <- names(R_square[[num.Sigma]]) <- c("lasso", "PCR")
        
        for(N in num.obs){  
          
            for(i in 1:times.sim){
              
                # generate data X and Y randomly
                # Z <- matrix(rnorm((N+1000)*p), (N+1000), p)
                # X.rand <- Z %*% (A.all[[num.Sigma]]) + matrix(mu, (N+1000), p, byrow = TRUE)
                Z <- matrix(rnorm((N+num.test)*p), (N+num.test), p)
                X.rand <- Z %*% (A.all[[num.Sigma]]) + matrix(mu, (N+num.test), p, byrow = TRUE)
                
                X.lasso.train <- X.rand[1:N, ]
                X.lasso.test <- X.rand[-(1:N), ]
                
                Y.lasso.train <- predict(res, newx = X.lasso.train, s = "lambda.min") + rnorm(N, 0, sd.error)
                Y.lasso.test <- predict(res, newx = X.lasso.test, s = "lambda.min") + rnorm(num.test, 0, sd.error)
                
                # generate X.pcr.train and X.pcr.test which are used in PCR
                
                # scale x.lasso.train and x.lasso.test
                X.lasso.train.mean <- apply(X.lasso.train, 2, mean)
                X.lasso.train.sd <- apply(X.lasso.train, 2, sd)
                X.lasso.train.scaled <- sweep(sweep(X.lasso.train, 2, X.lasso.train.mean, "-"), 2, X.lasso.train.sd, "/")
                X.lasso.test.scaled <- sweep(sweep(X.lasso.test, 2, X.lasso.train.mean, "-"), 2, X.lasso.train.sd, "/")
                
                # perform pca
                res.pca <- prcomp(X.lasso.train.scaled)
                
                pcc <- 1 + length(summary(res.pca)$importance[3, summary(res.pca)$importance[3, ] < 0.9])
                  # pcc : minimum number satisfing "cumulative contribution ratio > 0.9"
                if(pcc == 1) pcc <- 2
                
                X.pcr.train <- res.pca$x[, 1:pcc]
                X.pcr.test <- X.lasso.test.scaled %*% res.pca$rotation[, 1:pcc]
                
                # predict y and get RMSE
                res.lasso <- cv.glmnet(X.lasso.train, Y.lasso.train, nfolds=nfolds.glmnet)
                Y.lasso.train.pred <- predict(res.lasso, newx = X.lasso.train, s = "lambda.min")
                Y.lasso.test.pred <- predict(res.lasso, newx = X.lasso.test, s = "lambda.min")
                RMSE[[num.Sigma]][[1]] <- c(RMSE[[num.Sigma]][[1]], sqrt((sum((Y.lasso.test.pred - Y.lasso.test)^2))/num.test ))
                R_square[[num.Sigma]][[1]] <- c(R_square[[num.Sigma]][[1]], (sum((Y.lasso.train.pred - mean(Y.lasso.train))^2) / sum((Y.lasso.train - mean(Y.lasso.train))^2)) )
                
                res.pcr <- cv.glmnet(X.pcr.train, Y.lasso.train, nfolds=nfolds.glmnet)
                Y.pcr.train.pred <- predict(res.pcr, newx = X.pcr.train, s = "lambda.min")
                Y.pcr.test.pred <- predict(res.pcr, newx = X.pcr.test, s = "lambda.min")
                RMSE[[num.Sigma]][[2]] <- c(RMSE[[num.Sigma]][[2]], sqrt((sum((Y.pcr.test.pred - Y.lasso.test)^2))/num.test ))
                R_square[[num.Sigma]][[2]] <- c(R_square[[num.Sigma]][[2]], (sum((Y.pcr.train.pred - mean(Y.lasso.train))^2) / sum((Y.lasso.train - mean(Y.lasso.train))^2)) )
                
            }
            
            if(msg) cat(".")
            
        }
          
        dim(RMSE[[num.Sigma]][[1]]) <- dim(RMSE[[num.Sigma]][[2]]) <- dim(R_square[[num.Sigma]][[1]]) <- dim(R_square[[num.Sigma]][[2]]) <- c(times.sim, length(num.obs))  # convert vector of RMSE to matrix
        colnames(RMSE[[num.Sigma]][[1]]) <- colnames(RMSE[[num.Sigma]][[2]]) <- colnames(R_square[[num.Sigma]][[1]]) <- colnames(R_square[[num.Sigma]][[2]]) <- num.obs
        
        
        if(msg) cat("\n")
        }
    
    ans <- list(RMSE=RMSE, R_square=R_square)
    ans$call <- match.call()
    class(ans) <- "simrnet"
    ans

}